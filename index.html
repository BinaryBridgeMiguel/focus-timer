<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a2e">
    <title>Focus 40/5</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #eee;
            padding: 20px;
            user-select: none;
        }
        .container { text-align: center; width: 100%; max-width: 400px; }
        .mode-indicator {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #888;
            margin-bottom: 10px;
            transition: color 0.5s ease;
        }
        .mode-indicator.work { color: #4ecca3; }
        .mode-indicator.break { color: #ff6b6b; }
        .timer-display {
            font-size: 120px;
            font-weight: 200;
            letter-spacing: -5px;
            margin: 20px 0;
            font-variant-numeric: tabular-nums;
            transition: color 0.5s ease;
        }
        .timer-display.work { color: #4ecca3; }
        .timer-display.break { color: #ff6b6b; }
        .progress-ring {
            margin: 30px auto;
            position: relative;
            width: 280px;
            height: 280px;
        }
        .progress-ring svg { transform: rotate(-90deg); }
        .progress-ring circle { fill: none; stroke-width: 4; }
        .progress-ring .bg { stroke: #2a2a4a; }
        .progress-ring .progress {
            stroke: #4ecca3;
            stroke-linecap: round;
            transition: stroke 0.5s ease;
        }
        .progress-ring .progress.break { stroke: #ff6b6b; }
        .timer-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        .session-count { font-size: 14px; color: #666; margin-top: 10px; }
        .btn {
            background: transparent;
            border: 2px solid #4ecca3;
            color: #4ecca3;
            padding: 15px 50px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .btn:hover, .btn:active { background: #4ecca3; color: #1a1a2e; }
        .btn.break-btn { border-color: #ff6b6b; color: #ff6b6b; }
        .btn.break-btn:hover, .btn.break-btn:active { background: #ff6b6b; color: #1a1a2e; }
        .btn.stop-btn { border-color: #888; color: #888; padding: 10px 30px; font-size: 12px; }
        .btn.stop-btn:hover { background: #888; color: #1a1a2e; }
        .buttons { margin-top: 30px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        .message {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            text-align: center;
            font-size: 18px;
            transform: translateY(-100%);
            transition: transform 0.5s ease;
            z-index: 100;
        }
        .message.show { transform: translateY(0); }
        .message.work-done { background: linear-gradient(135deg, #4ecca3 0%, #3db892 100%); color: #1a1a2e; }
        .message.break-done { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%); color: #fff; }
        .breathing-guide {
            display: none;
            margin-top: 20px;
            font-size: 24px;
            animation: breathe 8s ease-in-out infinite;
        }
        .breathing-guide.show { display: block; }
        @keyframes breathe {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            25% { opacity: 1; transform: scale(1.1); }
            50% { opacity: 0.5; transform: scale(1); }
            75% { opacity: 1; transform: scale(1.1); }
        }
        .stats { position: fixed; bottom: 20px; font-size: 12px; color: #555; }
        .bg-notice {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 11px;
            color: #4ecca3;
            background: rgba(78, 204, 163, 0.1);
            padding: 5px 10px;
            border-radius: 20px;
            display: none;
        }
        .bg-notice.show { display: block; }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(78, 204, 163, 0.4); }
            50% { box-shadow: 0 0 0 20px rgba(78, 204, 163, 0); }
        }
        .pulse { animation: pulse 2s ease-in-out 3; }
    </style>
</head>
<body>
    <div class="bg-notice" id="bgNotice">‚úì Timer runs in background</div>
    <div class="message" id="message"></div>
    
    <div class="container">
        <div class="mode-indicator" id="modeIndicator">Ready</div>
        
        <div class="progress-ring">
            <svg width="280" height="280">
                <circle class="bg" cx="140" cy="140" r="130"></circle>
                <circle class="progress" id="progressCircle" cx="140" cy="140" r="130" 
                    stroke-dasharray="816.81" stroke-dashoffset="0"></circle>
            </svg>
            <div class="timer-center">
                <div class="timer-display" id="timerDisplay">40:00</div>
                <div class="session-count" id="sessionCount">Session 1</div>
            </div>
        </div>

        <div class="breathing-guide" id="breathingGuide">
            Breathe in... and out... üßò‚Äç‚ôÇÔ∏è
        </div>

        <div class="buttons">
            <button class="btn" id="startWorkBtn" onclick="startWork()">Start Work</button>
            <button class="btn break-btn" id="startBreakBtn" onclick="startBreak()" style="display:none;">Start Break</button>
            <button class="btn stop-btn" id="stopBtn" onclick="stopTimer()" style="display:none;">Stop</button>
        </div>
    </div>

    <div class="stats" id="stats">Today: 0 sessions ‚Ä¢ 0 min focused</div>

    <script>
        // Configuration
        const WORK_MINUTES = 40;
        const BREAK_MINUTES = 5;
        const CIRCUMFERENCE = 2 * Math.PI * 130;

        // State - using end time instead of counting down (works in background!)
        let endTime = null;
        let totalDuration = WORK_MINUTES * 60 * 1000;
        let isRunning = false;
        let isBreakMode = false;
        let sessionCount = 1;
        let totalFocusedMinutes = 0;
        let animationFrame = null;
        let worker = null;
        let checkInterval = null;

        // Save timer state to localStorage for recovery
        function saveTimerState() {
            if (isRunning && endTime) {
                localStorage.setItem('timerState', JSON.stringify({
                    endTime,
                    totalDuration,
                    isBreakMode,
                    savedAt: Date.now()
                }));
            } else {
                localStorage.removeItem('timerState');
            }
        }

        // Restore timer state from localStorage
        function restoreTimerState() {
            const saved = localStorage.getItem('timerState');
            if (saved) {
                const state = JSON.parse(saved);
                const remaining = state.endTime - Date.now();
                if (remaining > 0) {
                    endTime = state.endTime;
                    totalDuration = state.totalDuration;
                    isBreakMode = state.isBreakMode;
                    isRunning = true;
                    
                    // Restore UI
                    if (isBreakMode) {
                        modeIndicator.textContent = 'Breathing Break';
                        modeIndicator.className = 'mode-indicator break';
                        timerDisplay.className = 'timer-display break';
                        progressCircle.classList.add('break');
                        breathingGuide.classList.add('show');
                    } else {
                        modeIndicator.textContent = 'Focus Time';
                        modeIndicator.className = 'mode-indicator work';
                        timerDisplay.className = 'timer-display work';
                    }
                    
                    startWorkBtn.style.display = 'none';
                    startBreakBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                    
                    // Restart worker/timer
                    if (worker) {
                        worker.postMessage({ action: 'start', endTime });
                    }
                    startBackupInterval();
                    updateDisplay(remaining);
                    return true;
                } else {
                    // Timer expired while page was closed
                    localStorage.removeItem('timerState');
                    timerComplete();
                    return true;
                }
            }
            return false;
        }

        // Backup interval that checks every 5 seconds (survives better than worker sometimes)
        function startBackupInterval() {
            clearInterval(checkInterval);
            checkInterval = setInterval(() => {
                if (isRunning && endTime) {
                    const remaining = endTime - Date.now();
                    if (remaining <= 0) {
                        timerComplete();
                    } else {
                        updateDisplay(remaining);
                    }
                    saveTimerState();
                }
            }, 5000);
        }

        // Elements
        const timerDisplay = document.getElementById('timerDisplay');
        const progressCircle = document.getElementById('progressCircle');
        const modeIndicator = document.getElementById('modeIndicator');
        const message = document.getElementById('message');
        const startWorkBtn = document.getElementById('startWorkBtn');
        const startBreakBtn = document.getElementById('startBreakBtn');
        const stopBtn = document.getElementById('stopBtn');
        const breathingGuide = document.getElementById('breathingGuide');
        const sessionCountEl = document.getElementById('sessionCount');
        const stats = document.getElementById('stats');
        const bgNotice = document.getElementById('bgNotice');

        // Create Web Worker for background timing
        function createWorker() {
            const workerCode = `
                let timerId = null;
                let endTime = null;
                
                self.onmessage = function(e) {
                    if (e.data.action === 'start') {
                        endTime = e.data.endTime;
                        clearInterval(timerId);
                        timerId = setInterval(() => {
                            const remaining = endTime - Date.now();
                            if (remaining <= 0) {
                                clearInterval(timerId);
                                self.postMessage({ type: 'complete' });
                            } else {
                                self.postMessage({ type: 'tick', remaining });
                            }
                        }, 100);
                    } else if (e.data.action === 'stop') {
                        clearInterval(timerId);
                    }
                };
            `;
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // Initialize worker
        try {
            worker = createWorker();
            worker.onmessage = function(e) {
                if (e.data.type === 'tick') {
                    updateDisplay(e.data.remaining);
                } else if (e.data.type === 'complete') {
                    timerComplete();
                }
            };
            bgNotice.classList.add('show');
            setTimeout(() => bgNotice.classList.remove('show'), 3000);
        } catch (err) {
            console.log('Worker not supported, using fallback');
        }

        function loadStats() {
            const today = new Date().toDateString();
            const saved = localStorage.getItem('focusStats');
            if (saved) {
                const data = JSON.parse(saved);
                if (data.date === today) {
                    sessionCount = data.sessions || 1;
                    totalFocusedMinutes = data.minutes || 0;
                }
            }
            updateStats();
        }

        function saveStats() {
            localStorage.setItem('focusStats', JSON.stringify({
                date: new Date().toDateString(),
                sessions: sessionCount,
                minutes: totalFocusedMinutes
            }));
        }

        function updateStats() {
            stats.textContent = `Today: ${sessionCount - 1} sessions ‚Ä¢ ${totalFocusedMinutes} min focused`;
            sessionCountEl.textContent = `Session ${sessionCount}`;
        }

        function formatTime(ms) {
            const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
            const mins = Math.floor(totalSeconds / 60);
            const secs = totalSeconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateDisplay(remainingMs) {
            if (remainingMs === undefined) {
                remainingMs = endTime ? Math.max(0, endTime - Date.now()) : totalDuration;
            }
            
            timerDisplay.textContent = formatTime(remainingMs);
            
            const progress = 1 - (remainingMs / totalDuration);
            const offset = CIRCUMFERENCE * (1 - progress);
            progressCircle.style.strokeDashoffset = offset;
        }

        function playNotification() {
            // Vibrate if supported
            if (navigator.vibrate) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }

            // Show notification
            if (Notification.permission === 'granted') {
                const title = isBreakMode ? 'üßò‚Äç‚ôÇÔ∏è Break over!' : 'üí™ Focus complete!';
                const body = isBreakMode ? 'Ready to focus again?' : 'Time for a 5 min breathing break!';
                new Notification(title, { body, icon: 'üéØ', requireInteraction: true });
            }
        }

        function showMessage(text, type) {
            message.textContent = text;
            message.className = `message show ${type}`;
            setTimeout(() => message.classList.remove('show'), 3000);
        }

        function startWork() {
            isBreakMode = false;
            totalDuration = WORK_MINUTES * 60 * 1000;
            endTime = Date.now() + totalDuration;
            isRunning = true;
            
            modeIndicator.textContent = 'Focus Time';
            modeIndicator.className = 'mode-indicator work';
            timerDisplay.className = 'timer-display work';
            progressCircle.classList.remove('break');
            breathingGuide.classList.remove('show');
            
            startWorkBtn.style.display = 'none';
            startBreakBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            
            if (worker) {
                worker.postMessage({ action: 'start', endTime });
            } else {
                startFallbackTimer();
            }
            
            startBackupInterval();
            saveTimerState();
            updateDisplay();
        }

        function startBreak() {
            isBreakMode = true;
            totalDuration = BREAK_MINUTES * 60 * 1000;
            endTime = Date.now() + totalDuration;
            isRunning = true;
            
            modeIndicator.textContent = 'Breathing Break';
            modeIndicator.className = 'mode-indicator break';
            timerDisplay.className = 'timer-display break';
            progressCircle.classList.add('break');
            breathingGuide.classList.add('show');
            
            startWorkBtn.style.display = 'none';
            startBreakBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            
            if (worker) {
                worker.postMessage({ action: 'start', endTime });
            } else {
                startFallbackTimer();
            }
            
            startBackupInterval();
            saveTimerState();
            updateDisplay();
        }

        function stopTimer() {
            isRunning = false;
            endTime = null;
            
            if (worker) {
                worker.postMessage({ action: 'stop' });
            }
            cancelAnimationFrame(animationFrame);
            clearInterval(checkInterval);
            localStorage.removeItem('timerState');
            
            modeIndicator.textContent = 'Ready';
            modeIndicator.className = 'mode-indicator';
            timerDisplay.className = 'timer-display';
            progressCircle.classList.remove('break');
            breathingGuide.classList.remove('show');
            
            totalDuration = WORK_MINUTES * 60 * 1000;
            timerDisplay.textContent = formatTime(totalDuration);
            progressCircle.style.strokeDashoffset = 0;
            
            startWorkBtn.style.display = 'inline-block';
            startBreakBtn.style.display = 'none';
            stopBtn.style.display = 'none';
        }

        // Fallback timer for browsers without Worker support
        function startFallbackTimer() {
            function tick() {
                if (!isRunning || !endTime) return;
                
                const remaining = endTime - Date.now();
                if (remaining <= 0) {
                    timerComplete();
                } else {
                    updateDisplay(remaining);
                    animationFrame = requestAnimationFrame(tick);
                }
            }
            tick();
        }

        function timerComplete() {
            isRunning = false;
            endTime = null;
            clearInterval(checkInterval);
            localStorage.removeItem('timerState');
            playNotification();
            
            if (isBreakMode) {
                showMessage('Break over! Ready to focus? üí™', 'break-done');
                modeIndicator.textContent = 'Ready to Work';
                startWorkBtn.style.display = 'inline-block';
                startBreakBtn.style.display = 'none';
                breathingGuide.classList.remove('show');
            } else {
                totalFocusedMinutes += WORK_MINUTES;
                sessionCount++;
                saveStats();
                updateStats();
                
                showMessage('Great focus! Time for breathing üßò‚Äç‚ôÇÔ∏è', 'work-done');
                modeIndicator.textContent = 'Take a Break';
                startWorkBtn.style.display = 'none';
                startBreakBtn.style.display = 'inline-block';
                
                document.querySelector('.container').classList.add('pulse');
                setTimeout(() => document.querySelector('.container').classList.remove('pulse'), 6000);
            }
            
            stopBtn.style.display = 'none';
        }

        // Handle visibility change - recalculate time when tab becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && isRunning && endTime) {
                const remaining = endTime - Date.now();
                if (remaining <= 0) {
                    timerComplete();
                } else {
                    updateDisplay(remaining);
                }
            }
        });

        // Request notification permission
        document.body.addEventListener('click', () => {
            if (Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }, { once: true });

        // Initialize
        loadStats();
        
        // Try to restore timer state (in case page was refreshed/reopened)
        if (!restoreTimerState()) {
            updateDisplay();
        }

        // Service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }
    </script>
</body>
</html>
